<!DOCTYPE html>
<html lang="pt-BR">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Sistema de Requisitos</title>
      <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“‹</text></svg>">
      <script src="https://cdn.tailwindcss.com"></script>
      <script src="https://unpkg.com/feather-icons"></script>
      <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
      <script>
         tailwind.config = {
             theme: {
                 extend: {
                     colors: {
                         background: '#183462',
                         primary: '#2D6EE0',
                         accent: '#4CAF50'
                     }
                 }
             }
         }
      </script>
      <style>
         body {
         background-color: #183462;
         min-height: 100vh;
         }
         .tech-gradient {
         background: linear-gradient(135deg, #183462 0%, #2D6EE0 100%);
         }
         .glass-effect {
         background: rgba(255, 255, 255, 0.1);
         backdrop-filter: blur(10px);
         border: 1px solid rgba(255, 255, 255, 0.2);
         }
      </style>
   </head>
   <body class="text-white font-sans">
      <div class="min-h-screen py-8 px-4">
         <div class="max-w-2xl mx-auto">
            <!-- Header -->
            <div class="text-center mb-8" data-aos="fade-down">
               <h1 class="text-3xl font-bold mb-2">ðŸ“‹ Sistema de Requisitos</h1>
               <p class="text-blue-200">Gerencie seus requisitos de desenvolvimento</p>
            </div>
            <!-- Add Requirement Form -->
            <div class="glass-effect rounded-2xl p-6 mb-6" data-aos="fade-up">
               <form id="requirementForm" class="space-y-4">
                  <div>
                     <label class="block text-sm font-medium mb-2">Novo Requisito</label>
                     <textarea 
                        id="requirementText" 
                        rows="3" 
                        class="w-full px-4 py-3 bg-white/10 border border-white/20 rounded-xl focus:ring-2 focus:ring-blue-400 focus:border-transparent text-white placeholder-blue-200"
                        placeholder="Descreva o requisito..."
                        required
                        ></textarea>
                  </div>
                  <button type="submit" class="w-full bg-primary hover:bg-blue-600 text-white py-3 px-6 rounded-xl font-medium transition duration-200 flex items-center justify-center">
                  <i data-feather="plus" class="mr-2 w-5 h-5"></i>
                  Adicionar Requisito
                  </button>
               </form>
            </div>
            <!-- Import/Export/Clear Section -->
            <div class="glass-effect rounded-2xl p-6 mb-6" data-aos="fade-up">
               <div class="grid grid-cols-3 gap-4">
                  <div>
                     <label class="block text-sm font-medium mb-2">Importar CSV</label>
                     <input type="file" id="importFile" accept=".csv" class="hidden">
                     <label for="importFile" class="block w-full bg-primary hover:bg-blue-600 text-white py-3 px-4 rounded-xl text-center cursor-pointer transition duration-200">
                     <i data-feather="upload" class="inline mr-2 w-4 h-4"></i>
                     Importar
                     </label>
                  </div>
                  <div>
                     <label class="block text-sm font-medium mb-2">Exportar CSV</label>
                     <button id="exportBtn" class="w-full bg-accent hover:bg-green-600 text-white py-3 px-4 rounded-xl transition duration-200">
                     <i data-feather="download" class="inline mr-2 w-4 h-4"></i>
                     Exportar
                     </button>
                  </div>
                  <div>
                     <label class="block text-sm font-medium mb-2">Limpar Tudo</label>
                     <button id="clearBtn" class="w-full bg-red-600 hover:bg-red-700 text-white py-3 px-4 rounded-xl transition duration-200">
                     <i data-feather="trash-2" class="inline mr-2 w-4 h-4"></i>
                     Limpar
                     </button>
                  </div>
               </div>
            </div>
            <!-- Requirements List -->
            <div id="requirementsList" class="space-y-4 mb-8">
               <!-- Requirements will be loaded here -->
            </div>
            <!-- Summary Box -->
            <div class="glass-effect rounded-2xl p-6" data-aos="fade-up">
               <h3 class="text-lg font-semibold mb-4">Resumo dos Requisitos</h3>
               <textarea 
                  id="summaryText" 
                  rows="6" 
                  class="w-full px-4 py-3 bg-white/10 border border-white/20 rounded-xl mb-4 text-white placeholder-blue-200"
                  readonly
                  placeholder="Seus requisitos aparecerÃ£o aqui..."
                  ></textarea>
               <button id="copyBtn" class="w-full bg-accent hover:bg-green-600 text-white py-3 px-6 rounded-xl font-medium transition duration-200 flex items-center justify-center">
               <i data-feather="copy" class="mr-2 w-5 h-5"></i>
               Copiar Todos os Requisitos
               </button>
            </div>
         </div>
      </div>
      <!-- Edit Modal -->
      <div id="editModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center p-4 z-50">
         <div class="glass-effect rounded-2xl p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4">Editar Requisito</h3>
            <textarea 
               id="editText" 
               rows="4" 
               class="w-full px-4 py-3 bg-white/10 border border-white/20 rounded-xl mb-4 text-white"
               ></textarea>
            <div class="flex space-x-3">
               <button id="saveEditBtn" class="flex-1 bg-primary hover:bg-blue-600 text-white py-2 px-4 rounded-xl transition duration-200">
               Salvar
               </button>
               <button id="cancelEditBtn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded-xl transition duration-200">
               Cancelar
               </button>
            </div>
         </div>
      </div>
      <script>
            // Initialize database
            let db;
            // ðŸ”¹ Declara a variÃ¡vel `db` que vai armazenar a conexÃ£o com o banco IndexedDB.
            //    Inicialmente estÃ¡ vazia (undefined) e serÃ¡ preenchida quando o banco for aberto.
            
            // Nome do banco de dados
            const DB_NAME = 'RequirementsDB';
            // ðŸ”¹ Define uma constante `DB_NAME` com o nome do banco de dados.
            //    VocÃª pode trocar esse nome para algo mais descritivo, como "ControleEstoqueDB".
            
            // VersÃ£o do banco de dados
            const DB_VERSION = 1;
            // ðŸ”¹ Define a versÃ£o do banco. Sempre que vocÃª quiser alterar a estrutura
            //    (criar ou remover tabelas, Ã­ndices, etc.), deve aumentar esse nÃºmero
            //    para que o evento `onupgradeneeded` seja disparado e o banco seja atualizado.
            
            // Nome da store (tabela) padrÃ£o
            const STORE_NAME = 'requirements';
            // ðŸ”¹ Define o nome da object store (tabela) principal.
            //    Ã‰ onde os dados serÃ£o armazenados. VocÃª pode criar vÃ¡rias stores
            //    (como `produto`, `movimentacao_produto`, etc.).
            
            // Initialize app
            document.addEventListener('DOMContentLoaded', async () => {
               // ðŸ”¹ Aguarda o evento 'DOMContentLoaded', que dispara quando todo o HTML foi carregado,
               //    mas antes de carregar imagens e outros recursos pesados. 
               //    Assim, o JavaScript sÃ³ roda quando a estrutura da pÃ¡gina jÃ¡ estÃ¡ pronta.
            
               await initDB();
               // ðŸ”¹ Chama a funÃ§Ã£o `initDB()` para inicializar ou abrir o banco IndexedDB.
               //    Esse passo garante que vocÃª tenha acesso ao banco antes de usar dados.
            
               await initializeDefaultRequirements();
               // ðŸ”¹ Chama a funÃ§Ã£o `initializeDefaultRequirements()`.
               //    Provavelmente essa funÃ§Ã£o insere registros padrÃ£o (dados iniciais) no banco,
               //    caso ele esteja vazio.
            
               await loadRequirements();
               // ðŸ”¹ Chama `loadRequirements()` para carregar dados do banco e exibir na interface.
               //    Por exemplo, preenche tabelas ou listas na tela com as informaÃ§Ãµes.
            
               feather.replace();
               // ðŸ”¹ FunÃ§Ã£o da biblioteca Feather Icons. Substitui os placeholders de Ã­cones
               //    no HTML pelos SVGs reais. Garante que os Ã­cones apareÃ§am.
            
               setupEventListeners();
               // ðŸ”¹ Chama a funÃ§Ã£o `setupEventListeners()` para configurar eventos da interface,
               //    como cliques em botÃµes, submits de formulÃ¡rios, etc.
            });
            
            // Function to clear all requirements
            async function clearAllRequirements() {
               // ðŸ”¹ Declara uma funÃ§Ã£o assÃ­ncrona chamada `clearAllRequirements`.
               //    Ela vai apagar TODOS os registros da store (tabela) `STORE_NAME`.
            
               return new Promise((resolve, reject) => {
                  // ðŸ”¹ Retorna uma Promise para poder usar `await` quando chamar essa funÃ§Ã£o.
                  //    Se der certo, chama `resolve()`, se der erro, chama `reject()`.
            
                  const transaction = db.transaction([STORE_NAME], 'readwrite');
                  // ðŸ”¹ Cria uma transaÃ§Ã£o no IndexedDB para a store especificada (`STORE_NAME`).
                  //    O modo `'readwrite'` permite escrever/apagar dados.
            
                  const store = transaction.objectStore(STORE_NAME);
                  // ðŸ”¹ ObtÃ©m a referÃªncia para a object store (tabela) onde os dados estÃ£o armazenados.
            
                  const request = store.clear();
                  // ðŸ”¹ Faz a requisiÃ§Ã£o para limpar TODOS os registros da tabela.
            
                  request.onerror = () => reject(request.error);
                  // ðŸ”¹ Se houver erro ao limpar os dados, a Promise serÃ¡ rejeitada com a mensagem de erro.
            
                  request.onsuccess = () => resolve();
                  // ðŸ”¹ Se a operaÃ§Ã£o for concluÃ­da com sucesso, a Promise serÃ¡ resolvida.
               });
            }
            
            // Database functions
            async function initDB() {
               // ðŸ”¹ Declara uma funÃ§Ã£o assÃ­ncrona `initDB` para inicializar o IndexedDB.
               //    Ela retorna uma Promise para que possamos usar `await`.
            
               return new Promise((resolve, reject) => {
                  // ðŸ”¹ Cria uma nova Promise que serÃ¡ resolvida quando o banco estiver pronto.
                  //    Se algo der errado, serÃ¡ rejeitada com o erro.
            
                  const request = indexedDB.open(DB_NAME, DB_VERSION);
                  // ðŸ”¹ Faz uma requisiÃ§Ã£o para abrir (ou criar) o banco de dados com
                  //    nome `DB_NAME` e versÃ£o `DB_VERSION`.
                  //    Se mudar a versÃ£o, dispara `onupgradeneeded` para atualizar a estrutura.
            
                  request.onerror = () => reject(request.error);
                  // ðŸ”¹ Se houver um erro ao abrir/criar o banco, a Promise Ã© rejeitada.
            
                  request.onsuccess = () => {
                     db = request.result;
                     resolve();
                  };
                  // ðŸ”¹ Se o banco for aberto com sucesso, armazena a conexÃ£o em `db`
                  //    e resolve a Promise, sinalizando que o banco estÃ¡ pronto.
            
                  request.onupgradeneeded = (event) => {
                     const db = event.target.result;
                     // ðŸ”¹ Esse evento dispara apenas quando o banco Ã© criado
                     //    pela primeira vez ou a versÃ£o Ã© alterada.
                     //    Aqui Ã© onde criamos as tabelas (object stores).
            
                     if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, {
                           keyPath: 'id'
                        });
                        // ðŸ”¹ Cria uma object store (tabela) chamada `STORE_NAME`.
                        //    `keyPath: 'id'` define que o campo `id` serÃ¡ a chave primÃ¡ria.
            
                        store.createIndex('text', 'text', {
                           unique: false
                        });
                        // ðŸ”¹ Cria um Ã­ndice chamado `text` baseado no campo `text`.
                        //    Isso facilita buscas por esse campo. `unique: false` permite valores repetidos.
                     }
                  };
               });
            }
            async function addOrUpdateRequirement(requirement) {
               // ðŸ”¹ FunÃ§Ã£o assÃ­ncrona para ADICIONAR ou ATUALIZAR um registro na tabela STORE_NAME.
               //    Se o `requirement` jÃ¡ tiver um `id`, ele serÃ¡ atualizado.
               //    Se nÃ£o tiver, serÃ¡ criado um novo registro.
            
               return new Promise((resolve, reject) => {
                  // ðŸ”¹ Retorna uma Promise para que possamos usar `await`.
                  //    `resolve()` serÃ¡ chamado em caso de sucesso, `reject()` em caso de erro.
            
                  try {
                     const transaction = db.transaction([STORE_NAME], 'readwrite');
                     // ðŸ”¹ Cria uma transaÃ§Ã£o no IndexedDB para a store especificada.
                     //    `readwrite` permite adicionar/editar dados.
            
                     const store = transaction.objectStore(STORE_NAME);
                     // ðŸ”¹ ObtÃ©m a referÃªncia para a object store (tabela).
            
                     const request = store.put(requirement);
                     // ðŸ”¹ Usa `put()` para inserir ou atualizar um registro.
                     //    Se o objeto tiver a chave primÃ¡ria (`id`), ele serÃ¡ atualizado.
                     //    Se nÃ£o tiver, serÃ¡ criado com uma nova chave.
            
                     request.onerror = () => reject(request.error);
                     // ðŸ”¹ Se ocorrer um erro, a Promise serÃ¡ rejeitada com a mensagem de erro.
            
                     request.onsuccess = () => resolve(request.result);
                     // ðŸ”¹ Se a operaÃ§Ã£o for bem-sucedida, resolve a Promise retornando
                     //    a chave (`id`) do registro inserido/atualizado.
                  } catch (error) {
                     reject(error);
                     // ðŸ”¹ Caso ocorra algum erro inesperado (ex.: `db` nÃ£o definido),
                     //    ele Ã© capturado aqui e a Promise tambÃ©m Ã© rejeitada.
                  }
               });
            }
            async function getAllRequirements() {
               // ðŸ”¹ FunÃ§Ã£o assÃ­ncrona para BUSCAR todos os registros na store (tabela) definida em STORE_NAME.
               //    Ela retorna uma Promise que, ao ser resolvida, entrega todos os registros.
            
               return new Promise((resolve, reject) => {
                  // ðŸ”¹ Retorna uma Promise para que possamos usar `await`.
                  //    Se tudo der certo, chamamos `resolve(dados)`, senÃ£o `reject(erro)`.
            
                  const transaction = db.transaction([STORE_NAME], 'readonly');
                  // ðŸ”¹ Cria uma transaÃ§Ã£o no banco IndexedDB com permissÃ£o apenas de leitura (`readonly`).
                  //    Assim nÃ£o Ã© possÃ­vel alterar nada enquanto sÃ³ estamos lendo.
            
                  const store = transaction.objectStore(STORE_NAME);
                  // ðŸ”¹ Pega a referÃªncia da object store (tabela) onde os dados estÃ£o armazenados.
            
                  const index = store.index('createdAt'); // usa o Ã­ndice criado
                  const request = index.getAll(); // retorna os registros jÃ¡ em ordem crescente
            
                  request.onsuccess = () => {
                     // ðŸ”¹ Se a leitura for bem-sucedida, entra aqui.
            
                     // Sort by createdAt date
                     const sorted = request.result.sort((a, b) =>
                        new Date(a.createdAt) - new Date(b.createdAt)
                     );
                     // ðŸ”¹ Ordena os registros pelo campo `createdAt` em ordem crescente.
                     //    (Do mais antigo para o mais novo.)
            
                     resolve(sorted);
                     // ðŸ”¹ Retorna a lista ordenada atravÃ©s do `resolve`.
                  };
            
                  request.onerror = () => reject(request.error);
                  // ðŸ”¹ Se houver erro na leitura, rejeita a Promise com a mensagem de erro.
               });
            }
            async function deleteRequirement(id) {
               // ðŸ”¹ FunÃ§Ã£o assÃ­ncrona para DELETAR (remover) um registro da tabela (STORE_NAME)
               //    com base no seu `id`. 
            
               return new Promise((resolve, reject) => {
                  // ðŸ”¹ Retorna uma Promise. Se a exclusÃ£o der certo, chama `resolve()`.
                  //    Se der erro, chama `reject(erro)`.
            
                  const transaction = db.transaction([STORE_NAME], 'readwrite');
                  // ðŸ”¹ Abre uma transaÃ§Ã£o no banco IndexedDB para a store especificada.
                  //    O modo 'readwrite' Ã© necessÃ¡rio porque estamos modificando dados.
            
                  const store = transaction.objectStore(STORE_NAME);
                  // ðŸ”¹ ObtÃ©m a referÃªncia para a store (tabela) onde o registro estÃ¡ armazenado.
            
                  const request = store.delete(id);
                  // ðŸ”¹ Faz a requisiÃ§Ã£o para deletar o registro que tem o `id` informado.
            
                  request.onerror = () => reject(request.error);
                  // ðŸ”¹ Se houver algum erro ao tentar deletar, rejeita a Promise com a mensagem de erro.
            
                  request.onsuccess = () => resolve();
                  // ðŸ”¹ Se a exclusÃ£o for bem-sucedida, resolve a Promise (sem retornar nada especÃ­fico).
               });
            }
            // UI functions
            async function loadRequirements() {
               // ðŸ”¹ FunÃ§Ã£o assÃ­ncrona responsÃ¡vel por carregar os registros do banco
               //    e exibi-los na interface do usuÃ¡rio (HTML).
            
               const requirements = await getAllRequirements();
               // ðŸ”¹ Chama a funÃ§Ã£o que retorna todos os registros da store (`getAllRequirements`)
               //    e aguarda o resultado. `requirements` serÃ¡ um array de objetos.
            
               const list = document.getElementById('requirementsList');
               const summary = document.getElementById('summaryText');
               // ðŸ”¹ ObtÃ©m referÃªncias aos elementos HTML onde os dados serÃ£o exibidos:
               //    - `requirementsList`: container visual da lista
               //    - `summaryText`: textarea ou input resumido
            
               list.innerHTML = '';
               summary.value = '';
               // ðŸ”¹ Limpa qualquer conteÃºdo anterior antes de adicionar os registros novos.
            
               requirements.forEach((req, index) => {
                  // ðŸ”¹ Percorre todos os registros para criar elementos HTML dinamicamente.
            
                  // Add to list
                  const requirementElement = document.createElement('div');
                  requirementElement.className = 'glass-effect rounded-2xl p-4';
                  // ðŸ”¹ Cria um <div> para cada registro e aplica classes CSS para estilo.
            
                  requirementElement.innerHTML = `
                         <div class="flex justify-between items-start">
                             <div class="flex-1">
                                 <p class="text-white">${req.text}</p>
                             </div>
                             <div class="flex space-x-2 ml-4">
                                 <button class="edit-btn p-2 text-blue-300 hover:text-blue-100" data-id="${req.id}">
                                     <i data-feather="edit" class="w-4 h-4"></i>
                                 </button>
                                 <button class="delete-btn p-2 text-red-300 hover:text-red-100" data-id="${req.id}">
                                     <i data-feather="trash-2" class="w-4 h-4"></i>
                                 </button>
                             </div>
                         </div>
                     `;
                  // ðŸ”¹ Define o conteÃºdo HTML do elemento, incluindo:
                  //    - Texto do registro
                  //    - BotÃµes de editar e deletar com o `data-id` para identificar o registro
            
                  list.appendChild(requirementElement);
                  // ðŸ”¹ Adiciona o elemento recÃ©m-criado na lista visÃ­vel da interface.
            
                  // Add to summary
                  summary.value += `${index + 1}. ${req.text}\n`;
                  // ðŸ”¹ Atualiza o resumo textual (ex.: textarea), listando todos os registros.
               });
            
               feather.replace();
               // ðŸ”¹ Chama a funÃ§Ã£o da biblioteca Feather Icons para substituir
               //    todos os placeholders de Ã­cones pelos SVGs reais.
            }
            
            function setupEventListeners() {
               // ðŸ”¹ FunÃ§Ã£o para configurar todos os eventos da interface (UI), como cliques e submits.
            
               // Add requirement
               document.getElementById('requirementForm').addEventListener('submit', async (e) => {
                  // ðŸ”¹ Seleciona o formulÃ¡rio com id 'requirementForm' e adiciona um listener
                  //    para o evento `submit`. Quando o formulÃ¡rio Ã© enviado, essa funÃ§Ã£o Ã© chamada.
            
                  e.preventDefault();
                  // ðŸ”¹ Previne o comportamento padrÃ£o do formulÃ¡rio, que Ã© recarregar a pÃ¡gina.
                  //    Isso permite processar os dados via JavaScript.
            
                  const text = document.getElementById('requirementText').value.trim();
                  // ðŸ”¹ Pega o valor do input/textarea com id 'requirementText' e remove espaÃ§os extras
                  //    no inÃ­cio e no fim.
            
                  if (text) {
                     // ðŸ”¹ Verifica se o campo nÃ£o estÃ¡ vazio antes de salvar.
            
                     try {
                        const requirement = {
                           id: self.crypto.randomUUID(),
                           text: text,
                           createdAt: new Date().toISOString()
                        };
                        // ðŸ”¹ Cria um objeto `requirement` com:
                        //    - `id`: um UUID gerado aleatoriamente para identificar o registro
                        //    - `text`: o texto digitado pelo usuÃ¡rio
                        //    - `createdAt`: data/hora atual em formato ISO
            
                        await addOrUpdateRequirement(requirement);
                        // ðŸ”¹ Chama a funÃ§Ã£o que adiciona ou atualiza o registro no IndexedDB.
            
                        document.getElementById('requirementForm').reset();
                        // ðŸ”¹ Limpa o formulÃ¡rio apÃ³s salvar o registro.
            
                        await loadRequirements();
                        // ðŸ”¹ Atualiza a lista na interface com os registros mais recentes.
                     } catch (error) {
                        console.error('Error adding requirement:', error);
                        alert('Erro ao adicionar requisito. Verifique o console para mais detalhes.');
                        // ðŸ”¹ Caso haja algum erro durante a adiÃ§Ã£o do registro,
                        //    exibe no console e mostra um alerta para o usuÃ¡rio.
                     }
                  }
               });
            }
            // Edit requirement
            document.addEventListener('click', (e) => {
               // ðŸ”¹ Adiciona um listener global para cliques em todo o documento.
               //    Isso Ã© Ãºtil para elementos que sÃ£o criados dinamicamente (como os botÃµes de editar).
            
               if (e.target.closest('.edit-btn')) {
                  // ðŸ”¹ Verifica se o elemento clicado (ou algum pai) possui a classe 'edit-btn'.
                  //    `closest` sobe na Ã¡rvore do DOM atÃ© encontrar o elemento correspondente.
            
                  const id = e.target.closest('.edit-btn').dataset.id;
                  // ðŸ”¹ Pega o `data-id` do botÃ£o clicado, que identifica qual registro serÃ¡ editado.
            
                  // Get all requirement items
                  const requirementItems = document.querySelectorAll('#requirementsList > div');
                  // ðŸ”¹ Seleciona todos os elementos de registro dentro da lista de requisitos.
                  //    Cada `<div>` representa um item na interface.
            
                  // Find the requirement with matching id
                  let requirementElement = null;
                  for (const item of requirementItems) {
                     const btn = item.querySelector('.edit-btn');
                     if (btn && btn.dataset.id === id) {
                        requirementElement = item;
                        break;
                     }
                  }
                  // ðŸ”¹ Percorre todos os itens e encontra o que tem o mesmo `data-id` do botÃ£o clicado.
                  //    Assim sabemos qual registro na interface serÃ¡ editado.
            
                  if (requirementElement) {
                     document.getElementById('editText').value = requirementElement.querySelector('p').textContent;
                     // ðŸ”¹ Pega o texto do requisito e coloca no campo de ediÃ§Ã£o (`editText`) do modal.
            
                     document.getElementById('editModal').classList.remove('hidden');
                     // ðŸ”¹ Exibe o modal de ediÃ§Ã£o, removendo a classe 'hidden'.
            
                     document.getElementById('editModal').dataset.editingId = id;
                     // ðŸ”¹ Armazena no modal o `id` do registro que estÃ¡ sendo editado,
                     //    para usar quando salvar as alteraÃ§Ãµes.
                  }
               }
            });
            // Save edit
            document.getElementById('saveEditBtn').addEventListener('click', async () => {
               // ðŸ”¹ Adiciona um listener para o botÃ£o de salvar ediÃ§Ã£o no modal.
               //    Quando clicado, executa a funÃ§Ã£o assÃ­ncrona para atualizar o registro.
            
               const id = document.getElementById('editModal').dataset.editingId;
               // ðŸ”¹ Pega o `id` do registro que estÃ¡ sendo editado, armazenado no dataset do modal.
            
               const newText = document.getElementById('editText').value.trim();
               // ðŸ”¹ Pega o novo texto digitado pelo usuÃ¡rio e remove espaÃ§os extras.
            
               if (newText) {
                  // ðŸ”¹ SÃ³ prossegue se o campo nÃ£o estiver vazio.
            
                  const requirements = await getAllRequirements();
                  // ðŸ”¹ Carrega todos os registros do banco.
            
                  const requirement = requirements.find(req => req.id === id);
                  // ðŸ”¹ Procura o registro especÃ­fico que estÃ¡ sendo editado.
            
                  if (requirement) {
                     requirement.text = newText;
                     // ðŸ”¹ Atualiza o campo `text` do registro com o novo valor.
            
                     await addOrUpdateRequirement(requirement);
                     // ðŸ”¹ Salva o registro atualizado no banco (IndexedDB).
            
                     loadRequirements();
                     // ðŸ”¹ Atualiza a lista da interface para refletir a alteraÃ§Ã£o.
                  }
            
                  document.getElementById('editModal').classList.add('hidden');
                  // ðŸ”¹ Fecha o modal de ediÃ§Ã£o adicionando novamente a classe 'hidden'.
               }
            });
            
            // Cancel edit
            document.getElementById('cancelEditBtn').addEventListener('click', () => {
               // ðŸ”¹ Adiciona um listener para o botÃ£o "Cancelar" no modal de ediÃ§Ã£o.
            
               document.getElementById('editModal').classList.add('hidden');
               // ðŸ”¹ Apenas fecha o modal de ediÃ§Ã£o adicionando a classe 'hidden'.
               //    NÃ£o altera nenhum registro no banco.
            });
            
            // Delete requirement
            document.addEventListener('click', async (e) => {
               // ðŸ”¹ Adiciona um listener global para cliques em todo o documento.
               //    Isso Ã© Ãºtil para elementos dinÃ¢micos, como os botÃµes de deletar.
            
               if (e.target.closest('.delete-btn')) {
                  // ðŸ”¹ Verifica se o elemento clicado (ou algum pai) possui a classe 'delete-btn'.
            
                  const id = e.target.closest('.delete-btn').dataset.id;
                  // ðŸ”¹ Pega o `data-id` do botÃ£o clicado, que identifica qual registro serÃ¡ excluÃ­do.
            
                  if (confirm('Tem certeza que deseja excluir este requisito?')) {
                     // ðŸ”¹ Mostra uma confirmaÃ§Ã£o para o usuÃ¡rio antes de excluir.
            
                     await deleteRequirement(id);
                     // ðŸ”¹ Chama a funÃ§Ã£o para remover o registro do IndexedDB com base no `id`.
            
                     loadRequirements();
                     // ðŸ”¹ Atualiza a interface, removendo o item da lista visÃ­vel.
                  }
               }
            });
            // Copy summary
            document.getElementById('copyBtn').addEventListener('click', () => {
               // ðŸ”¹ Adiciona um listener para o botÃ£o "Copiar Resumo".
            
               const summary = document.getElementById('summaryText');
               // ðŸ”¹ Seleciona o textarea ou input que contÃ©m o resumo dos registros.
            
               summary.select();
               // ðŸ”¹ Seleciona todo o conteÃºdo do campo, preparando para copiar.
            
               document.execCommand('copy');
               // ðŸ”¹ Executa o comando de copiar para a Ã¡rea de transferÃªncia do sistema.
            
               alert('Requisitos copiados para a Ã¡rea de transferÃªncia!');
               // ðŸ”¹ Mostra uma mensagem de confirmaÃ§Ã£o para o usuÃ¡rio.
            });
            
            // Export CSV
            document.getElementById('exportBtn').addEventListener('click', async () => {
               // ðŸ”¹ Adiciona um listener para o botÃ£o "Exportar CSV".
            
               const requirements = await getAllRequirements();
               // ðŸ”¹ Carrega todos os registros do banco (IndexedDB).
            
               const csvContent = requirements.map(req =>
                  `"${req.id}","${req.text.replace(/"/g, '""')}","${req.createdAt}"`
               ).join('\n');
               // ðŸ”¹ Cria o conteÃºdo CSV:
               //    - Cada registro vira uma linha com aspas ao redor de cada campo
               //    - Substitui aspas internas por dupla aspas para escapar
               //    - Junta tudo em uma string, separando linhas por `\n`
            
               const blob = new Blob(['id,text,createdAt\n' + csvContent], {
                  type: 'text/csv'
               });
               // ðŸ”¹ Cria um arquivo Blob com o conteÃºdo CSV e define o tipo MIME como `text/csv`.
            
               const url = URL.createObjectURL(blob);
               // ðŸ”¹ Gera uma URL temporÃ¡ria para o Blob.
            
               const a = document.createElement('a');
               a.href = url;
               a.download = 'requisitos.csv';
               a.click();
               // ðŸ”¹ Cria um link temporÃ¡rio, define o arquivo para download e simula um clique
               //    para que o arquivo seja baixado.
            
               URL.revokeObjectURL(url);
               // ðŸ”¹ Libera a URL temporÃ¡ria criada para nÃ£o ocupar memÃ³ria.
            });
            // Import CSV
            document.getElementById('importFile').addEventListener('change', async (e) => {
               // ðŸ”¹ Adiciona um listener para o input de arquivo (`type="file"`).
               //    Sempre que o usuÃ¡rio seleciona um arquivo, a funÃ§Ã£o Ã© executada.
            
               const file = e.target.files[0];
               // ðŸ”¹ Pega o primeiro arquivo selecionado pelo usuÃ¡rio.
            
               if (file) {
                  const text = await file.text();
                  // ðŸ”¹ LÃª o conteÃºdo do arquivo como texto.
            
                  const lines = text.split('\n').slice(1); // Skip header
                  // ðŸ”¹ Separa o conteÃºdo em linhas e ignora a primeira linha (header do CSV).
            
                  for (const line of lines) {
                     if (line.trim()) {
                        const [id, text, createdAt] = line.split(',').map(field =>
                           field.trim().replace(/^"|"$/g, '')
                        );
                        // ðŸ”¹ Para cada linha nÃ£o vazia:
                        //    - Divide pelos separadores de vÃ­rgula
                        //    - Remove espaÃ§os extras e aspas externas
            
                        if (id && text) {
                           await addOrUpdateRequirement({
                              id: id,
                              text: text,
                              createdAt: createdAt || new Date().toISOString()
                           });
                           // ðŸ”¹ Adiciona ou atualiza o registro no banco IndexedDB.
                           //    Se `createdAt` estiver vazio, usa a data atual.
                        }
                     }
                  }
            
                  loadRequirements();
                  // ðŸ”¹ Atualiza a interface para mostrar os registros importados.
            
                  e.target.value = '';
                  // ðŸ”¹ Reseta o input de arquivo para permitir nova importaÃ§Ã£o.
               }
            });
            
            // Clear all requirements
            document.getElementById('clearBtn').addEventListener('click', async () => {
               // ðŸ”¹ Adiciona listener para o botÃ£o "Limpar Tudo".
            
               if (confirm('Tem certeza que deseja limpar todos os requisitos? Esta aÃ§Ã£o nÃ£o pode ser desfeita.')) {
                  // ðŸ”¹ Pergunta ao usuÃ¡rio para confirmar a aÃ§Ã£o, pois Ã© irreversÃ­vel.
            
                  await clearAllRequirements();
                  // ðŸ”¹ Chama a funÃ§Ã£o que limpa todos os registros da store.
            
                  loadRequirements();
                  // ðŸ”¹ Atualiza a interface para refletir que a lista estÃ¡ vazia.
               }
            });
            async function initializeDefaultRequirements() {
               // ðŸ”¹ FunÃ§Ã£o assÃ­ncrona para inicializar o banco com registros padrÃµes
               //    caso ainda nÃ£o exista nenhum registro.
            
               const requirements = await getAllRequirements();
               // ðŸ”¹ Pega todos os registros existentes do banco (IndexedDB).
            
               if (requirements.length === 0) {
                  // ðŸ”¹ Verifica se nÃ£o hÃ¡ registros. Se estiver vazio, adiciona os padrÃµes.
            
                  const defaultRequirements = [{
                        "id": "1234dedd-b3da-4fca-9eae-977044fb96db",
                        "text": "Cada registro deve possuir um UUID Ãºnico para identificaÃ§Ã£o, garantindo que nÃ£o haja duplicidade e permitindo atualizaÃ§Ã£o em vez de duplicaÃ§Ã£o.",
                        "createdAt": "2025-09-05T16:44:07.252Z"
                     },
                     {
                        "id": "2345418e-229e-4c13-8508-cde782aa13a2",
                        "text": "O sistema deve armazenar todos os registros localmente usando IndexedDB, garantindo que os dados permaneÃ§am disponÃ­veis mesmo apÃ³s fechar o navegador ou reiniciar o dispositivo.",
                        "createdAt": "2025-09-06T16:44:03.724Z"
                     },
                     // ... demais registros padrÃ£o ...
                  ];
                  // ðŸ”¹ Define um array com objetos que representam os registros padrÃµes.
                  //    Cada objeto possui:
                  //    - `id`: UUID Ãºnico
                  //    - `text`: descriÃ§Ã£o do requisito
                  //    - `createdAt`: data de criaÃ§Ã£o em formato ISO
            
                  for (const req of defaultRequirements) {
                     await addOrUpdateRequirement(req);
                     // ðŸ”¹ Itera sobre cada requisito padrÃ£o e adiciona/atualiza no banco.
                     //    Isso garante que o banco nÃ£o fique vazio na primeira execuÃ§Ã£o.
                  }
               }
            }

      </script>
   </body>
</html>
